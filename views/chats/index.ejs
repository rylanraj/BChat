<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <title>Chat</title>
  <style>
    body { margin: 0; padding-bottom: 3rem; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; }

    #form {height: 2em !important; border-radius: 12px; background: rgba(0, 0, 0, 0.15); padding: 0.25rem; bottom: 0; left: 0; right: 0; display: flex; height: 3rem; box-sizing: border-box; backdrop-filter: blur(10px); position: absolute; bottom: 0; }
    #input { font-size: 20px; border: none; padding: 0 1rem; flex-grow: 1; border-radius: 12px; margin: 0.25rem; }
    #input:focus { outline: none; }
  #form > button { background: #333; border: none; padding: 0 1rem; margin: 0.25rem; border-radius: 3px; outline: none; color: #fff;display: flex; justify-content: center; align-items: center;}

  /* Optimistic UI states */
  .pending { opacity: 0.55; position: relative; }
  .pending:after { content: '⏳'; font-size: 0.7rem; position: absolute; top: -6px; right: -6px; }
  .failed { opacity: 0.75; background: #f8d7da !important; position: relative; }
  .failed:after { content: '⚠'; font-size: 0.75rem; position: absolute; top: -6px; right: -6px; }
  /* Solution 1: Show timestamps on hover/tap only */
  .timestamp { 
    font-size: 0.65rem; 
    color: #888; 
    margin-top: 2px; 
    white-space: nowrap; 
    opacity: 0;
    transition: opacity 0.2s ease;
    pointer-events: none;
  }
  .area.send .timestamp { text-align: right; }
  .area.recep .timestamp { text-align: left; }
  
  /* Show timestamp on message hover */
  .area:hover .timestamp { 
    opacity: 1; 
  }
  
  /* Always show timestamp for pending/failed states */
  .pending .timestamp,
  .failed .timestamp { 
    opacity: 1; 
  }
  
  /* Add subtle hover effect to message bubbles */
  .area.send.bubble:hover,
  .area.recep.bubble:hover {
    transform: scale(1.01);
    transition: transform 0.1s ease;
  }
  
  /* Mobile tap functionality - show timestamp on tap */
  .area.show-timestamp .timestamp {
    opacity: 1;
  }

  </style>
</head>
<body>
<div class="user_profile_section">
  <div class="section_name">
    <h2>Chat</h2>
    <div class="inbox_display" id="display">
      <% otherUsers.forEach(user => { %>
        <div class="inbox" onclick="Inbox('<%= user.inboxID %>')">
          <div class="chat_message">

            <% const chatProfileSrc = user.profilePicture && /^https?:/i.test(user.profilePicture) ? user.profilePicture : ('/' + (user.profilePicture || 'images/default.jpg').replace(/^\/+/,'')); %>
            <img src="<%= chatProfileSrc %>" alt="pp" width="50" height="50" class="profile_picture">

            <div class="message_content">
              <h1><%= user.otherUserName %></h1>
              <p id="latest<%= user.inboxID %>"><%= user.lastMessage %></p>
              
            </div>
          </div>
        </div>
        <hr style="color:black !important; height: 2px;">
      <% }) %>


    </div>

  </div>
</div>
<div class="user_feed_section">
  <div class="section_name" style="width: 100%;">
    <div class="chat-upper">
      <h2 style="margin-right: auto !important; margin-bottom: auto !important;"><%= otherUserName %></h2>
      <button id="closeButton">X</button>
    </div>
    <%
      function isURL(str) {
        return str.startsWith('https');
      }
      function containsLongWord(str) {
        const words = str.split(' ');
        for (let i = 0; i < words.length; i++) {
          if (words[i].length > 19) {
            return true;
          }
        }
        return false;
      }
    %>
    <div class="chat_display">
      <ul id="discussion">
        <% chatMessages.forEach(chat => { %>
          <% if (userID==chat.SenderID) { %>
            <div class="area send">
              <div class="delete">
                <a onclick="deleteMessage('<%= chat.MessageID %>')">
                  <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-trash" viewBox="0 0 16 16">
                    <path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5m2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5m3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0z"/>
                    <path d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4zM2.5 3h11V2h-11z"/>
                  </svg>
                </a>
                <div id="popup<%= chat.MessageID %>" class="popup">
                  <div class="popup-content">
                    <p>Are you sure you want to delete this message?</p>
                    <button onclick="Delete('<%= chat.MessageID %>')">Yes</button>
                    <button onclick="Close('<%= chat.MessageID %>')">No</button>
                  </div>
                </div>
              </div>
              <div class="area send bubble">
                <% if(isURL(chat.Message)){ %>
                  <a href="<%= chat.Message %>" target="_blank">
                    <li class="url"><%= chat.Message %></li>
                  </a>
                <% } else if(containsLongWord(chat.Message)){ %>
                    <li class="longWord"><%= chat.Message %></li>
                <% } else { %>
                    <li class="individualMessage"><%= chat.Message %></li>
                <% } %>
                <div class="timestamp"><%= new Date(chat.DateSent).toLocaleString() %></div>
              </div>
            </div>

          <% } else { %>
            <div class="area recep" >
              <div class="area recep bubble">
                <% if(isURL(chat.Message)){ %>
                  <a href="<%= chat.Message %>" target="_blank">
                    <li class="url"><%= chat.Message %></li>
                  </a>
                <% } else if(containsLongWord(chat.Message)){ %>
                  <li class="longWord"><%= chat.Message %></li>
                <% } else { %>
                  <li class="individualMessage"><%= chat.Message %></li>
                <% } %>
                <div class="timestamp"><%= new Date(chat.DateSent).toLocaleString() %></div>
              </div>
            </div>
          <% } %>
        <% }) %>
      </ul>
    </div>

    <form  id="form" action="">
      <input id="input" autocomplete="off" spellcheck="true" maxlength="500"/><button>
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-arrow-right" viewBox="0 0 16 16">
          <path fill-rule="evenodd" d="M1 8a.5.5 0 0 1 .5-.5h11.793l-3.147-3.146a.5.5 0 0 1 .708-.708l4 4a.5.5 0 0 1 0 .708l-4 4a.5.5 0 0 1-.708-.708L13.293 8.5H1.5A.5.5 0 0 1 1 8"/>
        </svg>
      </button>
    </form>
  </div>
</div>
<script>
  window.onload = function() {
    // ... existing code ...

    // Scroll to the bottom of the chat
    const chatDisplay = document.querySelector('.chat_display');
    chatDisplay.scrollTop = chatDisplay.scrollHeight;
  };
  // Polling-based chat (Socket.IO removed)
  const inboxID = '<%= inboxID %>';
  const userID = '<%= userID %>';

  const form = document.getElementById('form');
  const messages = document.getElementById('discussion');
  const display = document.getElementById('display');

  function isURL(str) {
    return str.startsWith('https');
  }
  function containsLongWord(str) {
    const words = str.split(' ');
    for (let i = 0; i < words.length; i++) {
      if (words[i].length > 19) {
        return true;
      }
    }
    return false;
  }

  function deleteMessage(messageID) {
    document.getElementById('popup'+messageID).style.display = 'block';
  }
  async function Delete(messageID) {
    try {
      await fetch(`/api/chat/message/${messageID}`, { method: 'DELETE' });
      document.getElementById('popup'+messageID).style.display = 'none';
      // Force refresh
      await fetchMessages(true);
    } catch (e) { console.error('Delete failed', e); }
  }
  function Close(messageID) {
    document.getElementById('popup'+messageID).style.display = 'none';
  }
  function Inbox(otherInboxID) {
    window.location.href = '/chat/'+otherInboxID;
  }

  const pendingQueue = []; // track pending temp IDs in order
  form.addEventListener('submit', async (e) => {
    e.preventDefault();
    if (input.value) {
      const tempText = input.value; // capture text before clearing
      const tempId = 'temp-' + Date.now();
      appendOptimistic(tempId, tempText);
      pendingQueue.push({ tempId, text: tempText });
      const body = { message: tempText };
      input.value='';
      try {
        await fetch(`/api/chat/${inboxID}/messages`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body)
        });
        // Don't full refresh; next incremental poll will reconcile
        await fetchMessages(false, true);
      } catch (e) {
        console.error('Send failed', e);
        markFailed(tempId);
      }
    }
  });

  let lastMessageId = null;
  async function fetchMessages(initial=false, reconcile=false){
    try {
      const url = lastMessageId && !initial ? `/api/chat/${inboxID}/messages?sinceId=${lastMessageId}` : `/api/chat/${inboxID}/messages`;
      const res = await fetch(url);
      if(!res.ok) return;
      const data = await res.json();
      const fetched = data.messages || [];
      if (initial) {
        messages.innerHTML = '';
        fetched.forEach(appendMessage);
      } else if (fetched.length>0) {
        fetched.forEach(m => {
          if (m.SenderID == userID) {
            if (upgradePendingBubble(m)) {
              // upgraded existing optimistic bubble -> nothing else
            } else {
              appendMessage(m);
            }
          } else {
            appendMessage(m);
          }
        });
      }
      if (fetched.length>0) {
        lastMessageId = fetched[fetched.length-1].MessageID;
        document.getElementById('latest'+inboxID).innerHTML = fetched[fetched.length-1].Message;
        scrollToBottom();
      } else if (reconcile) {
        // If reconcile requested but no new messages returned, maybe full refresh needed for failures
      }
    } catch(e){ console.error('Fetch messages failed', e); }
  }
  function scrollToBottom(){
    const chatDisplay = document.querySelector('.chat_display');
    chatDisplay.scrollTop = chatDisplay.scrollHeight;
  }

  // Initial full load
  fetchMessages(true, false);
  // Poll every 3 seconds
  setInterval(() => fetchMessages(false,false), 3000);
  // Utility: sanitize html
  function escapeHtml(str){
    return str.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c]));
  }
  function classifyMessage(msg){
    if(isURL(msg)) return 'url';
    if(containsLongWord(msg)) return 'longWord';
    return 'individualMessage';
  }
  function appendOptimistic(tempId, text){
    const cls = classifyMessage(text);
    let content;
    if(cls==='url') {
      content = `<a href="${escapeHtml(text)}" target="_blank"><li class="url">${escapeHtml(text)}</li></a>`;
    } else if(cls==='longWord') {
      content = `<li class="longWord">${escapeHtml(text)}</li>`;
    } else {
      content = `<li class="individualMessage">${escapeHtml(text)}</li>`;
    }
    
    messages.innerHTML += `<div class="area send pending" id="${tempId}" data-text="${encodeURIComponent(text)}"><div class="area send bubble">${content}<div class="timestamp">sending...</div></div></div>`;
    const chatDisplay = document.querySelector('.chat_display');
    chatDisplay.scrollTop = chatDisplay.scrollHeight;
  }
  function appendMessage(chat){
    const isSender = userID==chat.SenderID;
    const msg = chat.Message;
    const id = chat.MessageID;
    const urlClass = isURL(msg) ? 'url' : containsLongWord(msg) ? 'longWord' : '';
    // Dedup: if already rendered (including upgraded pending) skip
    if (document.getElementById('msg-' + id)) return;
    const ts = formatTimestamp(chat.DateSent);
    if (isSender){
      let content;
      if (isURL(msg)) content = `<a href=${msg} target="_blank"><li class="url">${msg}</li></a>`;
      else if (containsLongWord(msg)) content = `<li class="longWord">${msg}</li>`;
      else content = `<li>${msg}</li>`;
      messages.innerHTML += `<div class=\"area send\" id=\"msg-${id}\"><div class=\"delete\"><a onclick=\"deleteMessage(${id})\">${trashIcon()}</a><div id=\"popup${id}\" class=\"popup\"><div class=\"popup-content\"><p>Are you sure you want to delete this message?</p><button onclick=\"Delete(${id})\">Yes</button><button onclick=\"Close(${id})\">No</button></div></div></div><div class=\"area send bubble\">${content}<div class=\"timestamp\">${ts}</div></div></div>`;
    } else {
      let content;
      if (isURL(msg)) content = `<a href=${msg} target="_blank"><li class="url">${msg}</li></a>`;
      else if (containsLongWord(msg)) content = `<li class="longWord">${msg}</li>`;
      else content = `<li>${msg}</li>`;
      messages.innerHTML += `<div class=\"area recep\" id=\"msg-${id}\"><div class=\"area recep bubble\">${content}<div class=\"timestamp\">${ts}</div></div></div>`;
    }
  }
  function upgradePendingBubble(message){
    // find a pending bubble with matching text (first match)
    const pendingEls = Array.from(document.querySelectorAll('.pending[data-text]'));
    const target = pendingEls.find(el => decodeURIComponent(el.getAttribute('data-text')) === message.Message);
    if (!target) return false;
    target.classList.remove('pending');
    target.removeAttribute('data-text');
    // Add delete control + assign popup id + timestamp
    const bubble = target.querySelector('.bubble');
    if (bubble) {
      // Wrap bubble with delete control if not present
      if (!target.querySelector('.delete')) {
        const wrapper = document.createElement('div');
        wrapper.className = 'delete';
        wrapper.innerHTML = `<a onclick=\"deleteMessage(${message.MessageID})\">${trashIcon()}</a><div id=\"popup${message.MessageID}\" class=\"popup\"><div class=\"popup-content\"><p>Are you sure you want to delete this message?</p><button onclick=\"Delete(${message.MessageID})\">Yes</button><button onclick=\"Close(${message.MessageID})\">No</button></div></div>`;
        target.insertBefore(wrapper, bubble);
      } else {
        // update existing delete anchor with real id if it was missing
      }
      // Replace sending... timestamp
      const tsEl = bubble.querySelector('.timestamp');
      if (tsEl) tsEl.textContent = formatTimestamp(message.DateSent);
      else bubble.innerHTML += `<div class=\"timestamp\">${formatTimestamp(message.DateSent)}</div>`;
    }
    // Replace temp id with real for potential future operations
    target.id = 'msg-' + message.MessageID;
    // Remove its entry from pendingQueue
    const idx = pendingQueue.findIndex(p => p.text === message.Message);
    if (idx !== -1) pendingQueue.splice(idx,1);
    return true;
  }
  function trashIcon(){
    return `
    <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"currentColor\" class=\"bi bi-trash\" viewBox=\"0 0 16 16\">\n      <path d=\"M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5m2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5m3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0z\"/>\n      <path d=\"M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4zM2.5 3h11V2h-11z\"/>\n    </svg>`;
  }
  function markFailed(tempId){
    const el = document.getElementById(tempId);
    if(el){
      el.classList.remove('pending');
      el.classList.add('failed');
    }
  }
  function formatTimestamp(raw){
    if(!raw) return '';
    try {
      const d = new Date(raw);
      // Format as e.g. 10:34 AM | Aug 9
      return d.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'}) + ' | ' + d.toLocaleDateString([], {month:'short', day:'numeric'});
    } catch { return ''; }
  }
  let closeButton = document.getElementById('closeButton');
  closeButton.addEventListener('click', () => {
    window.location.href = '/';
  });

  // Mobile tap functionality for showing timestamps
  document.addEventListener('click', (e) => {
    const bubble = e.target.closest('.bubble');
    if (bubble && !e.target.closest('.delete')) {
      const area = bubble.closest('.area');
      if (area) {
        // Toggle timestamp visibility on mobile/touch devices
        area.classList.toggle('show-timestamp');
        
        // Remove the class after 3 seconds on mobile
        setTimeout(() => {
          area.classList.remove('show-timestamp');
        }, 3000);
      }
    }
  });
</script>
</body>
</html>